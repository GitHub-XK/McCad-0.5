// File generated by CPPExt (Value)
//
//                     Copyright (C) 1991 - 2000 by
//                      Matra Datavision SA.  All rights reserved.
//
//                     Copyright (C) 2001 - 2004 by
//                     Open CASCADE SA.  All rights reserved.
//
// This file is part of the Open CASCADE Technology software.
//
// This software may be distributed and/or modified under the terms and
// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
// and appearing in the file LICENSE included in the packaging of this file.
//
// This software is distributed on an "AS IS" basis, without warranty of any
// kind, and Open CASCADE SA hereby disclaims all such warranties,
// including without limitation, any warranties of merchantability, fitness
// for a particular purpose or non-infringement. Please see the License for
// the specific terms and conditions governing rights and limitations under the
// License.

#ifndef _McCadMcVoid_Generator_HeaderFile
#define _McCadMcVoid_Generator_HeaderFile

#ifndef _Handle_McCadDiscDs_HSequenceOfDiscSolid_HeaderFile
#include <Handle_McCadDiscDs_HSequenceOfDiscSolid.hxx>
#endif
#ifndef _TopoDS_Shape_HeaderFile
#include <TopoDS_Shape.hxx>
#endif
#ifndef _Standard_Real_HeaderFile
#include <Standard_Real.hxx>
#endif
#ifndef _Standard_Integer_HeaderFile
#include <Standard_Integer.hxx>
#endif
#ifndef _Standard_Boolean_HeaderFile
#include <Standard_Boolean.hxx>
#endif
#ifndef _Handle_TopTools_HSequenceOfShape_HeaderFile
#include <Handle_TopTools_HSequenceOfShape.hxx>
#endif
#ifndef _Handle_McCadDiscDs_HSequenceOfDiscFace_HeaderFile
#include <Handle_McCadDiscDs_HSequenceOfDiscFace.hxx>
#endif
class McCadDiscDs_HSequenceOfDiscSolid;
class TopoDS_Shape;
class TopTools_HSequenceOfShape;
class McCadDiscDs_HSequenceOfDiscFace;
#include <Message_ProgressIndicator.hxx>
#include <McCadDiscDs_DiscSolid.hxx>

//#include <McCadConvertTools_VoidGenerator.hxx>
/*
#include <McCadGUI_BaseDialogPtr.hxx>
#include <McCadGUI_BaseDialog.hxx>
#include <McCadGUI_ProgressDialogPtr.hxx>
#include <McCadGUI_ProgressDialog.hxx>
#include <McCadGUI_InputDialogPtr.hxx>
#include <McCadGUI_InputDialog.hxx>
#include <McCadGUI_GuiFactoryPtr.hxx>
#include <McCadGUI_GuiFactory.hxx>
*/

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif

//! \brief Core of Void Completion

//! The input is a bounding box for the whole input model. <br>
//! The bounding box will be cut with all linear faces of the input solids beginning
//! with the face with the largest face area. The threshold for the cut face area is
//! defined by myMinDecompositionFaceArea. All faces smaller than this value will not
//! be used for decomposition. This feature is neccessary for large models with loads
//! of small faces.
//! The number of volumes produced by the cutting algorithm can be restricted by the
//! parameter myMaxNbOfPreDecomposition<br>
//! After the cutting an overlap test among the void volumes and the input solids will
//! be performed. The number of overlapps allowed for one single void volume is defined
//! by myMaxComplementedShapes.<br>
//! Void volumes which have a higher number of collisions are called monster voids
//! Monster voids will be decomposed further with a smaller cut face threshold defined
//! by myMinRedecompositionFaceArea
//! if the second cut still leaves a monster void, the resulting monster void will
//! be handled as a usual void volume.

class McCadMcVoid_Generator  {

public:

    void* operator new(size_t,void* anAddress)
      {
        return anAddress;
      }
    void* operator new(size_t size)
      {
        return Standard::Allocate(size);
      }
    void  operator delete(void *anAddress)
      {
        if (anAddress) Standard::Free((Standard_Address&)anAddress);
      }
 // Methods PUBLIC
 //
//! std ctor
Standard_EXPORT McCadMcVoid_Generator();

//! ctor accepting a sequence of discretized solids
Standard_EXPORT McCadMcVoid_Generator(Handle(McCadDiscDs_HSequenceOfDiscSolid)& theDShape);

//! set the discretized solids
//! OBSOLETE!
Standard_EXPORT   void SetDiscSolids(const Handle(McCadDiscDs_HSequenceOfDiscSolid)& theSolids) ;

//! returns the discretized solids
//! OBSOLETE!
Standard_EXPORT   Handle_McCadDiscDs_HSequenceOfDiscSolid GetDiscSolids() const;

//! Returns a list of discretized void volumes
Standard_EXPORT   Handle_McCadDiscDs_HSequenceOfDiscSolid GetDiscVoids() const;

//! perform generation of void volumes
//! calls this->PreDecompose() and this->VoidGenerate()
Standard_EXPORT   void Init() ;

//! Set input bounding box as a Sequence of Solids
//! Bounding box is meant to be cut by all planar faces of the input model.
//! Input solid can already be predecomposed, hence the sequence instead of one single solid.
//! This might be neccessary to avoid excessive decomposition of the bounding box.
Standard_EXPORT   void SetBSolid(const Handle_TopTools_HSequenceOfShape& theBSolid) ;

//! Return the input bounding box
//! OBSOLETE!
Standard_EXPORT   Handle_TopTools_HSequenceOfShape GetBSolid() const;

//! Generate a sphere which contains the bounding box
//! The sphere is used for MCNP to be able to easile describe the whole universe.
//! Everything outside the sphere is the outer space which is unintersting for the
//! computations. The space between the sphere and the bounding box is unintersting also for the
//! calculations but is quite handy for geometry bug tracking.
//! So the space inbetween will have neutron importance 1 in MCNP.
//! Then one can define a surface source on the sphere with an inward direction.
//! Lost particles will lead to geometry bugs.
Standard_EXPORT   TopoDS_Shape MkOuterSpace() ;

//! defines the minimum volume of predecomposed void volumes
Standard_EXPORT   void SetMinVolume(const Standard_Real theVol) ;

//! Sets the number of maximal allowed overlaps between one void volume and
//! input solids. A void volume which collides with more input solids than this
//! value is called monster void.
//! Monster voids will be processed a second time with a smaller cutting face
//! threshold.
Standard_EXPORT   void SetMaxComplementedShapes(const Standard_Integer theNumb) ;

//! Defines the maximal number of void volumes for the decomposition process.
Standard_EXPORT   void SetMaxNbOfPreDecomposition(const Standard_Integer theNumb) ;

//! Set the minimum threshold for linear face of the input model to be considered
//! as a cut face for the decomposition of the bounding box
Standard_EXPORT   void SetMinDecompositionFaceArea(const Standard_Real theArea) ;

//! Set the minimum threshold for linear face of the input model to be considered
//! as a cut face for the decomposition of monster voids
Standard_EXPORT   void SetMinRedecompositionFaceArea(const Standard_Real theArea) ;

//! Sets the tolerance for cutting
//! OBSOLETE!
Standard_EXPORT   void SetTolerance(const Standard_Real theTol) ;

//! returns true if the void generation was finished succesfully
Standard_EXPORT   Standard_Boolean IsDone() const;

//! Set parameters for the discretization of the generated void volumes
//! Discretization means, that sample points will be spread over all faces
//! of all void volumes to perform overlap tests with the input solids.
Standard_EXPORT   void SetDiscParameter(const Standard_Integer theMaxNbPnt,const Standard_Integer theMinNbPnt,const Standard_Real theXRes,const Standard_Real theYRes,const Standard_Real theTol) ;

//! ??? closer investigation neccessary: somehow used by McCadMcVoid::ApproxGeomEqualFaces(,,theCFRes)
Standard_EXPORT   void SetCutFaceResolution(const Standard_Real theCFRes) ;

//! Discretize the decomposed void volumes, i.e. spread sample points on their
//! faces for overlap test
Standard_EXPORT void VoidVoxelization(Handle(TopTools_HSequenceOfShape)& voidSolids) ;

//! Tests if an input solid is polyhedral, i.e. consists of planar faces only
Standard_EXPORT Standard_Boolean IsPolyhedral(TopoDS_Shape& shp) ;

//! perform fast overlap test for polyhedra
Standard_EXPORT Standard_Boolean PolyhedralOverlap(TopoDS_Shape& shp1, TopoDS_Shape& shp2) ;

//! sets the GUI related progress indicator
Standard_EXPORT     void SetProgressIndicator(Handle_Message_ProgressIndicator& thePI);

//! perform the decomposition of the volumes of the bounding box with a face
//! from the input solids
Standard_EXPORT   Handle_TopTools_HSequenceOfShape Decompose(Handle(TopTools_HSequenceOfShape)& tmpBoxSeq,TopoDS_Shape& aFaceSolid) ;

protected:

 // Methods PROTECTED
 //


 // Fields PROTECTED


private:

 // Methods PRIVATE
 //

Standard_EXPORT   void PreDecompose() ;


Standard_EXPORT   void VoidGenerate() ;


Standard_EXPORT   Handle_TopTools_HSequenceOfShape GoDecompose(Handle(TopTools_HSequenceOfShape)& BoxSeq,const Handle(McCadDiscDs_HSequenceOfDiscFace)& theVCutFace,const Standard_Integer MaxNbVoids) ;


Standard_EXPORT   Standard_Boolean FacesIntersect(TopoDS_Shape& shp1, TopoDS_Shape& shp2);

 // Fields PRIVATE
 //
Handle_McCadDiscDs_HSequenceOfDiscSolid myVSolids;
Handle_McCadDiscDs_HSequenceOfDiscSolid myVVoids;
Handle_TopTools_HSequenceOfShape myBSolid;
TopoDS_Shape mySphere;
Standard_Real myMinVolume;
Standard_Integer myMaxComplementedShapes;
Standard_Integer myMaxNbOfPreDecomposition;
Standard_Real myMinDecompositionFaceArea;
Standard_Real myMinRedecompositionFaceArea;
Standard_Real myTolerance;
Standard_Boolean myIsDone;
Standard_Integer myMaxNbPnt;
Standard_Integer myMinNbPnt;
Standard_Real myXlen;
Standard_Real myYlen;
Standard_Real myCFRes;

Handle_Message_ProgressIndicator myPI;

};





// other Inline functions and methods (like "C++: function call" methods)
//


#endif
